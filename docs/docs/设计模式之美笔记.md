# 封装，抽象，继承，多态总结

##面向对象
面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。

## 封装
What：通过访问权限控制 隐藏信息，保护数据访问。外部仅能通过类提供的有限的接口访问、修改内部数据
How：暴露有限接口和属性，需要编程语言提供访问控制的语法。
Why：提高代码可维护性；降低接口复杂度，提高类的易用性。

##抽象
What: 隐藏具体实现，使用者只需关心功能，无需关心实现。
How: 通过接口类或者抽象类实现，特殊语法机制非必须。
Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。

##继承
What: 表示 is-a 关系，分为单继承和多继承。
How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。
Why: 解决代码复用问题。

##多态
What: 子类替换父类，在运行时调用子类的实现。
How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。
Why: 提高代码扩展性和复用性。

3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性。易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。


#面向对象编程相比面向过程编程有哪些优势
面向对象编程相比起面向过程编程的优势主要有三个。
1.对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
2.面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。
3.从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。


#面向对象代码注意点

##封装注意点

###1. 不要滥用 getter、setter 方法
比如封装了一个ShoppingCart 
有个成员变量 private double totalPrice; 参数不要暴露setter方法，防止外部修改。
还有个 private List items = new ArrayList<>(); 此时不能随便暴露 getItems 方法，
因为list被外部获取了可以修改其内容，暴露不应该暴露的 getter 方法 违反了面向对象编程的封装特性。
如果需要获取items来展示的话 最好使用 Collections.unmodifiableList(this.items); 方法，让 getItems 方法返回一个不可被修改的 UnmodifiableList 集合容器
```
public List getItems() { return Collections.unmodifiableList(this.items); }
```
不过这个方法还有个问题，依然可以获取其中的一个item 修改其属性  
//todo

总结：
在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，
但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。

###2. 不要滥用全局变量和全局方法

1. 我们把程序中所有用到的常量，都集中地放到这个 Constants 类中。
不过，定义一个如此大而全的 Constants 类，并不是一种很好的设计思路。为什么这么说呢？原因主要有以下几点。
首先，这样的设计会影响代码的可维护性。

其次，这样的设计还会增加代码的编译时间。当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。不要小看编译花费的时间，对于一个非常大的工程项目来说，编译一次项目花费的时间可能是几分钟，甚至几十分钟。而我们在开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率。
(可能的小知识点：修改一个类的时候 编译会导致依赖它的类文件重新编译，会影响编译时间。所以尽量让修改多的类减少被依赖可能是比较重要的)

最后，这样的设计还会影响代码的复用性。

另外 接口中似乎也可以定义属性，不过王争说接口不能包含属性的 用接口不合适，待了解
//TODO

改进Constants类的设计思路：
第一种是将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们放到 MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中
还有一种设计模式之美作者王争个人觉得更好的设计思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig 类用到了 Redis 配置相关的常量，那我们就直接将这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性。


2. Utils类 加了很多static 方法
实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。
这种设计往往是为了代码复用。有的时候A,B类并不存在继承关系，此时用继承来复用代码就不合适，往往就放到Utils类中了。
它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。
首先思考是否可以放到别的类中，如果觉得有必要用Utils还是得用。

我们设计 Utils 类的时候，最好也能细化一下，针对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUtils、StringUtils、UrlUtils 等，不要设计一个过于大而全的 Utils 类。


3. 定义数据和方法分离的类
MVC 每一层中可能都有 VO BO，这些类只有数据没有方法，是典型的面向过程，不过这个模式被广泛使用的原因是？
MVC 跟贫血模型没直接关系，数据和操作分离的贫血模式-贫血模型流行的原因：实现简单和上手快。
//TODO

#贫血模型
只包含数据，不包含业务逻辑的类，就叫作贫血模型。
贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。
贫血模型比较适合简单的业务。

#基于充血模型的 DDD 开发模式
充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。
领域驱动设计，即 DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。
充血模型 因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，在开发复杂系统时更加有优势。



# 接口和抽象类的区别
一句话总结：抽象类为了解决复用，接口为了解耦。

## 抽象类
抽象类不允许被实例化，只能被继承
抽象类可以包含属性和方法
子类继承抽象类，必须实现抽象类中的所有抽象方法
### 抽象类存在的意义
1.继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。
2.如果不使用抽象也能解决复用，但是父类中提供的空方法的设计意图就比较难以理解，或者增加子类的时候容易忘记实现某个方法，所以用抽象更易于理解，
也避免了父类被误用。

##接口
接口不能包含属性（也就是成员变量）。
接口只能声明方法，方法不能包含代码实现。（java新特性 可以使用 default 来包含实现）
类实现接口的时候，必须实现接口中声明的所有方法。
###接口存在的意义
接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。
调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。
接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。


#设计原则  -SOLID 

# S.设计原则之-单一职责原则（SRP）
单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP。
这个原则的英文描述是这样的：A class or module should have a single responsibility。
如果我们把它翻译成中文，那就是：一个类或者模块只负责完成一个职责（或者功能）。
单一职责主要是为了 提高类的内聚性，避免将不相关的功能耦合 实现代码的高内聚、低耦合

我们可以先写一个粗粒度的类，满足业务需求。
随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构

判断原则
1. 类中的代码行数、函数或属性过多，  会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；
2. 类依赖的其他类过多，  或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；
3. 私有方法过多，  我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
4. 比较难给类起一个合适名字，  很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
5. 类中大量的方法都是集中操作类中的某几个属性，  比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。

但是类的职责不是越单一越好，拆分过细 会适得其反，反而降低内聚性，也会影响代码的可维护性。


# O.设计原则之-开闭原则（对扩展开放、修改关闭 OCP）
开闭原则的英文全称是 Open Closed Principle，简写为 OCP。
开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则。
对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！
这个设计原则 的精髓在于权衡利弊，修改在不同层面上不一样，如对于类可能是修改，对于方法可能是扩展。

1. 添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。
两点注意：第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。

2. 如何做到“对扩展开放、修改关闭”？
我们要时刻具备扩展意识、抽象意识、封装意识。



# L.设计原则之-里式替换原则。（LSP）
里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP
子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

关键点在于 用子类代替父类 不能出现父类不会出现的问题，比如子类方法抛出异常，父类却不会。
解读：子类在设计的时候，要遵守父类的行为约定（或者叫协议）。
父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。
这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。
实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。

LSP的意义：
一、改进已有实现。例如程序最开始实现时采用了低效的排序算法，改进时使用LSP实现更高效的排序算法。
二、指导程序开发。告诉我们如何组织类和子类（subtype），子类的方法（非私有方法）要符合contract。
三、改进抽象设计。如果一个子类中的实现违反了LSP，那么是不是考虑抽象或者设计出了问题。



# I.设计原则之-接口隔离原则（ISP）
接口隔离原则的英文翻译是“ Interface Segregation Principle”，缩写为 ISP。
Robert Martin 在 SOLID 原则中是这样定义它的：“Clients should not be forced to depend upon interfaces that they do not use。”
直译成中文的话就是：客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。

我们可以把“接口”理解为下面三种东西：
一组 API 接口集合
单个 API 接口或函数
OOP 中的接口概念

总结：接口隔离原则：我只要我想要的，不想要的别给我


# D.设计原则之-依赖反转原则（DIP）
依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。
高层模块（high-level modules）不要依赖低层模块（low-level）。
高层模块和低层模块应该通过抽象（abstractions）来互相依赖。
除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。
所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。

##控制反转（IOC）
框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。
程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。
这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。
在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。
控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。

##依赖注入（DI）
一句话来概括依赖注入 就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。
依赖注入可以提高可扩展性 可以灵活地替换依赖的类


#设计原则 KISS原则
Keep It Simple and Stupid.
Keep It Short and Simple.
Keep It Simple and Straightforward.
翻译成中文就是：尽量保持简单。
KISS 原则是保持代码可读和可维护的重要手段。

1. 复杂的正则表达式 虽然行数少 但是比较难懂，并不符合KISS原则 
（正则表达式其实编译比较耗时，如果非要用正则  将正则编译当作静态变量更快，避免每次用都要编译，可能可以提升一个数量级的执行效率）
2. 有些方法实现性能更高，但是可读性比较差，实现困难，除非是性能瓶颈  还是应该选择实现简单可读性更好的实现。

并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。
tips:KMP字符串匹配算法 以快速高效著称，逻辑复杂、实现难度大、可读性差的特点，但它并不违反 KISS 原则。
当我们需要处理长文本字符串匹配问题（几百 MB 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 Vim、Word 等文本编辑器），
又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 KMP 算法。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。
本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。 不过如果业务简单还强行要用kmp 就属于违背KISS原则了

kiss原则总结：
1. 不要使用同事可能不懂的技术来实现代码。
2. 不要重复造轮子，要善于使用已经有的工具类库。
3. 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。


#设计原则 YAGNI
YAGNI 原则的英文全称是：You Ain’t Gonna Need It。
直译就是：你不会需要它。这条原则也算是万金油了。
当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。
实际上，这条原则的核心思想就是：不要做过度设计。当前不需要的就不要做 。


#设计原则 DRY
它的英文描述为：Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。
并不是两段代码长得一样，那就是违反 DRY 原则了。这是很多人对这条原则存在的误解。
实际上，重复的代码不一定违反 DRY 原则，而且有些看似不重复的代码也有可能违反 DRY 原则。

三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。
这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了。

我们可以不写可复用的代码，但一定不能写重复的代码。

##怎么提高代码复用性？
1. 减少代码耦合
2. 满足单一职责原则
3. 模块化
4. 业务与非业务逻辑分离
5. 通用代码下沉
6. 继承、多态、抽象、封装
7. 应用模板等设计模式


#设计原则之 迪米特法则（LOD）
用于实现高内聚、松耦合
“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。
所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。
所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合。

迪米特法则的英文翻译是：Law of Demeter，缩写是 LOD。 还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。

##不该有直接依赖关系的类之间，不要有依赖

##有依赖关系的类之间，尽量只依赖必要的接口
比如 序列化和反序列化，如果只有一个类 其他地方可能只用到其中一种，可以通过抽象 把序列化 反序列化抽象成两个接口，这样使用的地方只感知到其中一个接口功能，
不知道另一个，就实现了迪米特法则，这也体现了 基于接口而非实现编程。
总结：基于最小接口而非最大实现编程”。


# 设计原则之-基于接口而非实现编程
这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。
“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。
## 原则需要做到的
1. 函数的命名不能暴露任何实现细节 如uploadToAliyun 就不合适 改为upload更好
2. 封装具体的实现细节。 比如某个下载上传流程包括了生成token等内容，就不适合让外部自己调用，应该封装对外提供一个包含细节的方法。
3. 为实现类定义抽象的接口。

如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。



# 设计原则之-组合优于继承，多用组合少用继承。
1. 为什么不推荐使用继承？
继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。
我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。

2. 组合相比继承有哪些优势？
继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。

接口只声明方法，不定义实现。也就是说，每个实现接口的类都需要写一遍接口方法，并且实现逻辑是一样的，这就会导致代码重复的问题。
那这个问题可以通过 通过组合和委托技术来消除代码重复

3. 如何判断该用组合还是继承？
如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。




# 面向对象设计步骤
划分职责进而识别出有哪些类；
定义类及其属性和方法；
定义类与类之间的交互关系；
将类组装起来并提供执行入口。

# 如何判断模块划分是否合理
1. 如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重。
2. 我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。
比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。
但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。


#“五级工程师模型”

> 第五级：能独立解决问题，完成工程工作；
> 第四级：能指导和带领其他人一同完成更有影响力的工作；
> 第三级：能独立设计和实现产品，并且在市场上获得成功；
> 第二级：能设计和实现别人不能做出的产品，也就是说他的作用很难取代；
> 第一级：开创一个产业

