# 封装，抽象，继承，多态总结

##面向对象
面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。

## 封装
What：通过访问权限控制 隐藏信息，保护数据访问。外部仅能通过类提供的有限的接口访问、修改内部数据
How：暴露有限接口和属性，需要编程语言提供访问控制的语法。
Why：提高代码可维护性；降低接口复杂度，提高类的易用性。

##抽象
What: 隐藏具体实现，使用者只需关心功能，无需关心实现。
How: 通过接口类或者抽象类实现，特殊语法机制非必须。
Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。

##继承
What: 表示 is-a 关系，分为单继承和多继承。
How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。
Why: 解决代码复用问题。

##多态
What: 子类替换父类，在运行时调用子类的实现。
How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。
Why: 提高代码扩展性和复用性。

3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性。易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。


#面向对象编程相比面向过程编程有哪些优势
面向对象编程相比起面向过程编程的优势主要有三个。
1.对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
2.面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。
3.从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。


#面向对象代码注意点

##封装注意点

###1. 不要滥用 getter、setter 方法
比如封装了一个ShoppingCart 
有个成员变量 private double totalPrice; 参数不要暴露setter方法，防止外部修改。
还有个 private List items = new ArrayList<>(); 此时不能随便暴露 getItems 方法，
因为list被外部获取了可以修改其内容，暴露不应该暴露的 getter 方法 违反了面向对象编程的封装特性。
如果需要获取items来展示的话 最好使用 Collections.unmodifiableList(this.items); 方法，让 getItems 方法返回一个不可被修改的 UnmodifiableList 集合容器
```
public List getItems() { return Collections.unmodifiableList(this.items); }
```
不过这个方法还有个问题，依然可以获取其中的一个item 修改其属性  
//todo

总结：
在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，
但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。

###2. 不要滥用全局变量和全局方法

1. 我们把程序中所有用到的常量，都集中地放到这个 Constants 类中。
不过，定义一个如此大而全的 Constants 类，并不是一种很好的设计思路。为什么这么说呢？原因主要有以下几点。
首先，这样的设计会影响代码的可维护性。

其次，这样的设计还会增加代码的编译时间。当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。不要小看编译花费的时间，对于一个非常大的工程项目来说，编译一次项目花费的时间可能是几分钟，甚至几十分钟。而我们在开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率。
(可能的小知识点：修改一个类的时候 编译会导致依赖它的类文件重新编译，会影响编译时间。所以尽量让修改多的类减少被依赖可能是比较重要的)

最后，这样的设计还会影响代码的复用性。

另外 接口中似乎也可以定义属性，不过王争说接口不能包含属性的 用接口不合适，待了解
//TODO

改进Constants类的设计思路：
第一种是将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们放到 MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中
还有一种设计模式之美作者王争个人觉得更好的设计思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig 类用到了 Redis 配置相关的常量，那我们就直接将这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性。


2. Utils类 加了很多static 方法
实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。
这种设计往往是为了代码复用。有的时候A,B类并不存在继承关系，此时用继承来复用代码就不合适，往往就放到Utils类中了。
它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。
首先思考是否可以放到别的类中，如果觉得有必要用Utils还是得用。

我们设计 Utils 类的时候，最好也能细化一下，针对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUtils、StringUtils、UrlUtils 等，不要设计一个过于大而全的 Utils 类。


3. 定义数据和方法分离的类
MVC 每一层中可能都有 VO BO，这些类只有数据没有方法，是典型的面向过程，不过这个模式被广泛使用的原因是？
MVC 跟贫血模型没直接关系，数据和操作分离的贫血模式-贫血模型流行的原因：实现简单和上手快。
//TODO

#贫血模型
只包含数据，不包含业务逻辑的类，就叫作贫血模型。
贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。
贫血模型比较适合简单的业务。

#基于充血模型的 DDD 开发模式
充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。
领域驱动设计，即 DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。
充血模型 因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，在开发复杂系统时更加有优势。



# 接口和抽象类的区别
一句话总结：抽象类为了解决复用，接口为了解耦。

## 抽象类
抽象类不允许被实例化，只能被继承
抽象类可以包含属性和方法
子类继承抽象类，必须实现抽象类中的所有抽象方法
### 抽象类存在的意义
1.继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。
2.如果不使用抽象也能解决复用，但是父类中提供的空方法的设计意图就比较难以理解，或者增加子类的时候容易忘记实现某个方法，所以用抽象更易于理解，
也避免了父类被误用。

##接口
接口不能包含属性（也就是成员变量）。
接口只能声明方法，方法不能包含代码实现。（java新特性 可以使用 default 来包含实现）
类实现接口的时候，必须实现接口中声明的所有方法。
###接口存在的意义
接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。
调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。
接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。



# 设计原则之-基于接口而非实现编程
这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。
“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。
## 原则需要做到的
1. 函数的命名不能暴露任何实现细节 如uploadToAliyun 就不合适 改为upload更好
2. 封装具体的实现细节。 比如某个下载上传流程包括了生成token等内容，就不适合让外部自己调用，应该封装对外提供一个包含细节的方法。
3. 为实现类定义抽象的接口。

如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。



# 设计原则之-组合优于继承，多用组合少用继承。
1. 为什么不推荐使用继承？
继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。
我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。

2. 组合相比继承有哪些优势？
继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。

接口只声明方法，不定义实现。也就是说，每个实现接口的类都需要写一遍接口方法，并且实现逻辑是一样的，这就会导致代码重复的问题。
那这个问题可以通过 通过组合和委托技术来消除代码重复

3. 如何判断该用组合还是继承？
如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。




